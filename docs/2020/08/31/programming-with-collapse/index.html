<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Hugo 0.72.0" />


<title>Efficient Grouped Programming in R and/or C/C&#43;&#43; - with the collapse Package - R, Econometrics, High Performance</title>
<meta property="og:title" content="Efficient Grouped Programming in R and/or C/C&#43;&#43; - with the collapse Package - R, Econometrics, High Performance">


  <link href='/Rblog/favicon.ico' rel='icon' type='image/x-icon'/>



  








<link href='//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css' rel='stylesheet' type='text/css' />



<link rel="stylesheet" href="/Rblog/css/fonts.css" media="all">
<link rel="stylesheet" href="/Rblog/css/main.css" media="all">



  </head>
  <body>
    <div class="wrapper">
      <header class="header">
        <nav class="nav">
  <a href="/Rblog/" class="nav-logo">
    <img src="/Rblog/images/sebkrantz.png"
         width="50"
         height="50"
         alt="Logo">
  </a>

  <ul class="nav-links">
    
    <li><a href="/Rblog/about/">About</a></li>
    
    <li><a href="https://github.com/SebKrantz">GitHub</a></li>
    
    <li><a href="https://twitter.com/collapse_R">Twitter</a></li>
    
  </ul>
</nav>

      </header>


<main class="content" role="main">

  <article class="article">
    
    <span class="article-duration">10 min read</span>
    

    <h1 class="article-title">Efficient Grouped Programming in R and/or C/C&#43;&#43; - with the collapse Package</h1>

    
    <span class="article-date">2020-08-31</span>
    

    <div class="article-content">
      


<p><a href="https://sebkrantz.github.io/collapse/"><em>collapse</em></a> is a C/C++ based package for data transformation and statistical computing in R. Among other features it introduces an excellent and highly efficient architecture for grouped (and weighted) statistical programming in R. This post briefly explains this architecture and demonstrates:</p>
<ol style="list-style-type: decimal">
<li><p>How to program highly efficient grouped statistical computations and data manipulations in R using the grouped functions supplied by <em>collapse</em>.</p></li>
<li><p>How to use the grouping mechanism of <em>collapse</em> with custom C/C++ code to create further efficient grouped functions/operations in R.</p></li>
</ol>
<div id="essentials-collapse-grouping-objects" class="section level1">
<h1>Essentials: <em>collapse</em> Grouping Objects</h1>
<p><em>collapse</em> uses grouping objects as essential inputs for grouped computations. These objects are created from vectors or lists of vectors (i.e. data frames) using the function <code>GRP()</code>:</p>
<pre class="r"><code>library(collapse)
# A dataset supplied with collapse providing sectoral value added (VA) and employment (EMP)
head(GGDC10S, 3)
##   Country Regioncode             Region Variable Year AGR MIN MAN PU CON WRT TRA FIRE GOV OTH SUM
## 1     BWA        SSA Sub-saharan Africa       VA 1960  NA  NA  NA NA  NA  NA  NA   NA  NA  NA  NA
## 2     BWA        SSA Sub-saharan Africa       VA 1961  NA  NA  NA NA  NA  NA  NA   NA  NA  NA  NA
## 3     BWA        SSA Sub-saharan Africa       VA 1962  NA  NA  NA NA  NA  NA  NA   NA  NA  NA  NA
fdim(GGDC10S)
## [1] 5027   16

# Creating a grouping object (by default return.order = FALSE as the ordering is typically not needed)
g &lt;- GRP(GGDC10S, c(&quot;Country&quot;, &quot;Variable&quot;), return.order = TRUE)
# Printing it
print(g)
## collapse grouping object of length 5027 with 85 ordered groups
## 
## Call: GRP.default(X = GGDC10S, by = c(&quot;Country&quot;, &quot;Variable&quot;), return.order = TRUE), X is unordered
## 
## Distribution of group sizes: 
##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##    4.00   53.00   62.00   59.14   63.00   65.00 
## 
## Groups with sizes: 
## ARG.EMP  ARG.VA BOL.EMP  BOL.VA BRA.EMP  BRA.VA 
##      62      62      61      62      62      62 
##   ---
## VEN.EMP  VEN.VA ZAF.EMP  ZAF.VA ZMB.EMP  ZMB.VA 
##      62      63      52      52      52      52
# Plotting it
plot(g)</code></pre>
<p><img src="/Rblog/post/2020-08-31-programming-with-collapse_files/figure-html/unnamed-chunk-1-1.png" width="100%" />
Grouping is done very efficiently using radix-based ordering in C (thanks to <em>data.table</em> source code). The structure of this object is shown below:</p>
<pre class="r"><code>str(g)
## List of 8
##  $ N.groups   : int 85
##  $ group.id   : int [1:5027] 46 46 46 46 46 46 46 46 46 46 ...
##  $ group.sizes: int [1:85] 62 61 62 52 63 62 61 62 61 64 ...
##  $ groups     :&#39;data.frame&#39;: 85 obs. of  2 variables:
##   ..$ Variable: chr [1:85] &quot;EMP&quot; &quot;EMP&quot; &quot;EMP&quot; &quot;EMP&quot; ...
##   .. ..- attr(*, &quot;label&quot;)= chr &quot;Variable&quot;
##   .. ..- attr(*, &quot;format.stata&quot;)= chr &quot;%9s&quot;
##   ..$ Country : chr [1:85] &quot;ARG&quot; &quot;BOL&quot; &quot;BRA&quot; &quot;BWA&quot; ...
##   .. ..- attr(*, &quot;label&quot;)= chr &quot;Country&quot;
##   .. ..- attr(*, &quot;format.stata&quot;)= chr &quot;%9s&quot;
##  $ group.vars : chr [1:2] &quot;Variable&quot; &quot;Country&quot;
##  $ ordered    : Named logi [1:2] TRUE FALSE
##   ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;GRP.sort&quot; &quot;initially.ordered&quot;
##  $ order      : int [1:5027] 2583 2584 2585 2586 2587 2588 2589 2590 2591 2592 ...
##   ..- attr(*, &quot;starts&quot;)= int [1:85] 1 63 124 186 238 301 363 424 486 547 ...
##   ..- attr(*, &quot;maxgrpn&quot;)= int 65
##   ..- attr(*, &quot;sorted&quot;)= logi FALSE
##  $ call       : language GRP.default(X = GGDC10S, by = c(&quot;Variable&quot;, &quot;Country&quot;), return.order = TRUE)
##  - attr(*, &quot;class&quot;)= chr &quot;GRP&quot;</code></pre>
<p>The first three slots of this object provide the number of unique groups, a group-id matching each value/row to a group<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>, and a vector of group-sizes. The fourth slot provides the unique groups (default <code>return.groups = TRUE</code>), followed by the names of the grouping variables, a logical vector showing whether the grouping is ordered (default <code>sort = TRUE</code>), and the ordering vector which can be used to sort the data alphabetically according to the grouping variables (default <code>return.order = FALSE</code>).</p>
</div>
<div id="grouped-programming-in-r" class="section level1">
<h1>Grouped Programming in R</h1>
<p><em>collapse</em> provides a whole ensemble of C++ based generic statistical functions that can use these ‘GRP’ objects to internally perform (column-wise) grouped (and weighted) computations on vectors, matrices and data frames in R. Their names are contained in the global macro <code>.FAST_FUN</code>:</p>
<pre class="r"><code>.FAST_FUN
##  [1] &quot;fmean&quot;      &quot;fmedian&quot;    &quot;fmode&quot;      &quot;fsum&quot;       &quot;fprod&quot;      &quot;fsd&quot;        &quot;fvar&quot;      
##  [8] &quot;fmin&quot;       &quot;fmax&quot;       &quot;fnth&quot;       &quot;ffirst&quot;     &quot;flast&quot;      &quot;fNobs&quot;      &quot;fNdistinct&quot;
## [15] &quot;fscale&quot;     &quot;fbetween&quot;   &quot;fwithin&quot;    &quot;fHDbetween&quot; &quot;fHDwithin&quot;  &quot;flag&quot;       &quot;fdiff&quot;     
## [22] &quot;fgrowth&quot;</code></pre>
<p>Additional functions supporting grouping objects are <code>TRA</code> (grouped replacing and sweeping out statistics), <code>BY</code> (split-apply-combine computing) and <code>collap</code> (advanced data aggregation with multiple functions).</p>
<p>To provide a brief example, we can compute a grouped mean of the above data using:</p>
<pre class="r"><code>head(fmean(GGDC10S[6:16], g))
##                AGR         MIN         MAN           PU        CON         WRT        TRA
## ARG.EMP  1419.8013    52.08903   1931.7602   101.720936   742.4044   1982.1775   648.5119
## ARG.VA  14951.2918  6454.94152  36346.5456  2722.762554  9426.0033  26633.1292 14404.6626
## BOL.EMP   964.2103    56.03295    235.0332     5.346433   122.7827    281.5164   115.4728
## BOL.VA   3299.7182  2846.83763   3458.2904   664.289574   729.0152   2757.9795  2727.4414
## BRA.EMP 17191.3529   206.02389   6991.3710   364.573404  3524.7384   8509.4612  2054.3731
## BRA.VA  76870.1456 30916.64606 223330.4487 43549.277879 70211.4219 178357.8685 89880.9743
##                 FIRE        GOV        OTH         SUM
## ARG.EMP    627.79291   2043.471   992.4475   10542.177
## ARG.VA    8547.37278  25390.774  7656.3565  152533.839
## BOL.EMP     44.56442         NA   395.5650    2220.524
## BOL.VA    1752.06208         NA  4383.5425   22619.177
## BRA.EMP   4413.54448   5307.280  5710.2665   54272.985
## BRA.VA  183027.46189 249135.452 55282.9748 1200562.671</code></pre>
<p>By default (<code>use.g.names = TRUE</code>), group names are added as names (vectors) or row-names (matrices and data frames) to the result. For data frames we can also add the grouping columns again using<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>:</p>
<pre class="r"><code>head(add_vars(g[[&quot;groups&quot;]], fmean(get_vars(GGDC10S, 6:16), g, use.g.names = FALSE)))
##   Country Variable        AGR         MIN         MAN           PU        CON         WRT        TRA
## 1     ARG      EMP  1419.8013    52.08903   1931.7602   101.720936   742.4044   1982.1775   648.5119
## 2     ARG       VA 14951.2918  6454.94152  36346.5456  2722.762554  9426.0033  26633.1292 14404.6626
## 3     BOL      EMP   964.2103    56.03295    235.0332     5.346433   122.7827    281.5164   115.4728
## 4     BOL       VA  3299.7182  2846.83763   3458.2904   664.289574   729.0152   2757.9795  2727.4414
## 5     BRA      EMP 17191.3529   206.02389   6991.3710   364.573404  3524.7384   8509.4612  2054.3731
## 6     BRA       VA 76870.1456 30916.64606 223330.4487 43549.277879 70211.4219 178357.8685 89880.9743
##           FIRE        GOV        OTH         SUM
## 1    627.79291   2043.471   992.4475   10542.177
## 2   8547.37278  25390.774  7656.3565  152533.839
## 3     44.56442         NA   395.5650    2220.524
## 4   1752.06208         NA  4383.5425   22619.177
## 5   4413.54448   5307.280  5710.2665   54272.985
## 6 183027.46189 249135.452 55282.9748 1200562.671</code></pre>
<p>The execution cost of all of these functions is extremely small, so the performance is essentially limited by C++, not by R.</p>
<pre class="r"><code>library(microbenchmark)
microbenchmark(call = add_vars(g[[&quot;groups&quot;]], fmean(get_vars(GGDC10S, 6:16), g, use.g.names = FALSE)))
## Unit: microseconds
##  expr    min      lq     mean   median     uq      max neval
##  call 230.71 234.503 330.9058 236.9575 262.17 8180.156   100</code></pre>
<p>We can use these functions to write very efficient grouped code in R. This shows a simple application in panel data econometrics comparing a pooled OLS to a group means, a between and a within estimator computed on the demeaned data<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>:</p>
<pre class="r"><code>Panel_Ests &lt;- function(formula, data, pids) {
  # Get variables as character string, first variable is dependent variable
  vars &lt;- all.vars(formula)
  # na_omit and qM are faster replacements for na.omit and as.matrix
  data_cc &lt;- na_omit(qM(get_vars(data, vars)), na.attr = TRUE)
  cc &lt;- attr(data_cc, &quot;na.action&quot;)
  # We don&#39;t need the unique groups or the call. ss() is faster replacement for [.data.frame 
  g &lt;- GRP(ss(data, -cc, pids), return.groups = FALSE, call = FALSE)
  # Computing group means
  mean_data_cc &lt;- fmean(data_cc, g, use.g.names = FALSE)
  # This computes regression coefficients
  reg &lt;- function(x) qr.coef(qr(cbind(Intercept = 1, x[, -1L, drop = FALSE])), x[, 1L])
  
  qM(list(Pooled = reg(data_cc),
          Means = reg(mean_data_cc),
          # This replaces data values with the group-mean -&gt; between-group estimator
          Between = reg(TRA(data_cc, mean_data_cc, &quot;replace_fill&quot;, g)),
          # This subtracts the group-means -&gt; within-group estimator
          Within = reg(TRA(data_cc, mean_data_cc, &quot;-&quot;, g))))
}

# Value Added data
round(Panel_Ests(SUM ~ AGR + MIN + MAN, fsubset(GGDC10S, Variable == &quot;VA&quot;), &quot;Country&quot;), 4)
##                 Pooled        Means      Between  Within
## Intercept 2605610.3402 2305205.3650 2030326.5556  0.0000
## AGR            -0.7828       1.4656      -5.6343 -0.1935
## MIN             2.5863      -0.3798       6.4096  2.4478
## MAN             3.1535       3.1953       4.1260  2.8924

# Employment data
round(Panel_Ests(SUM ~ AGR + MIN + MAN, fsubset(GGDC10S, Variable == &quot;EMP&quot;), &quot;Country&quot;), 4)
##              Pooled     Means   Between   Within
## Intercept 2218.8727 1120.2277 1053.6433   0.0000
## AGR          0.8963    0.7866    0.7699   1.0885
## MIN        -11.8597  -12.4496  -12.7368 -13.6924
## MAN          4.6062    5.1998    5.2988   4.3131</code></pre>
<p>It would be easy to add an option for sampling weights as <code>fmean</code> also supports weighted grouped computations. A benchmark below shows that this series of estimators is executed very efficiently and scales nicely to large data (quite a bit faster than using <code>plm</code> to do it).</p>
<pre class="r"><code># Benchmark on VA data
VA_data &lt;- fsubset(GGDC10S, Variable == &quot;VA&quot;)
microbenchmark(call = Panel_Ests(SUM ~ AGR + MIN + MAN, VA_data, &quot;Country&quot;))
## Unit: milliseconds
##  expr      min       lq     mean   median       uq      max neval
##  call 1.515902 1.581946 1.985501 1.719613 2.135293 6.163119   100</code></pre>
<p>There are lots and lots of other applications that can be devised in R using the <code>.FAST_FUN</code> and efficient programming with grouping objects.</p>
<div id="creating-grouped-functions-in-cc" class="section level2">
<h2>Creating Grouped Functions in C/C++</h2>
<p>It is also possible to just use ‘GRP’ objects as input to new grouped functions written in C or C++. Below I use <em>Rcpp</em> to create a generic grouped <code>anyNA</code> function for vectors:</p>
<pre class="cpp"><code>// [[Rcpp::plugins(cpp11)]]
#include &lt;Rcpp.h&gt;
using namespace Rcpp;

// Inputs: 
// x - A vector of any type 
// ng - The number of groups - supplied by GRP() in R
// g - An integer grouping vector - supplied by GRP() in R

// Output: A plain logical vector of size ng

template &lt;int RTYPE&gt;
LogicalVector ganyNACppImpl(Vector&lt;RTYPE&gt; x, int ng, IntegerVector g) {
  int l = x.size();
  if(l != g.size()) stop(&quot;length(x) must match length(g)&quot;);
  LogicalVector out(ng);

  if(RTYPE == REALSXP) { // numeric vector: all logical operations on NA/NaN evaluate to false, except != which is true.
    for(int i = 0; i &lt; l; ++i) if(x[i] != x[i]) out[g[i]-1] = true;
  } else { // other vectors
    for(int i = 0; i &lt; l; ++i) if(x[i] == Vector&lt;RTYPE&gt;::get_na()) out[g[i]-1] = true;
  }

  return out;
}

// disabling other data types (lists, complex values etc.)
template &lt;&gt;
LogicalVector ganyNACppImpl(Vector&lt;CPLXSXP&gt; x, int ng, IntegerVector) {
  stop(&quot;Not supported SEXP type!&quot;);
}

template &lt;&gt;
LogicalVector ganyNACppImpl(Vector&lt;VECSXP&gt; x, int ng, IntegerVector) {
  stop(&quot;Not supported SEXP type!&quot;);
}

template &lt;&gt;
LogicalVector ganyNACppImpl(Vector&lt;RAWSXP&gt; x, int ng, IntegerVector) {
  stop(&quot;Not supported SEXP type!&quot;);
}

template &lt;&gt;
LogicalVector ganyNACppImpl(Vector&lt;EXPRSXP&gt; x, int ng, IntegerVector) {
  stop(&quot;Not supported SEXP type!&quot;);
}

// [[Rcpp::export]]
LogicalVector ganyNACpp(const SEXP&amp; x, int ng = 0, const IntegerVector&amp; g = 0){
  RCPP_RETURN_VECTOR(ganyNACppImpl, x, ng, g);
}
</code></pre>
<p>On the R side things are then pretty simple:</p>
<pre class="r"><code>library(Rcpp)   
sourceCpp(&quot;ganyNA.cpp&quot;)

ganyNA &lt;- function(x, g, use.g.names = TRUE) {
  # Option group.sizes = FALSE prevents tabulation of levels if a factor is passed
  g &lt;- GRP(g, return.groups = use.g.names, group.sizes = FALSE, call = FALSE)
  res &lt;- ganyNACpp(x, g[[1L]], g[[2L]])
  # GRPnames creates unique group names. For vectors they need not be character typed.
  if(use.g.names) return(setNames(res, GRPnames(g, force.char = FALSE)))
  res
}</code></pre>
<p>Strictly speaking there are different options to set this up: <code>GRP()</code> is a S3 generic function with a default method applying to atomic vectors and lists / data frames, but also a ‘factor’ method converting factors to ‘GRP’ objects. Above I have used the generic <code>GRP</code> function with the option <code>group.sizes = FALSE</code>, so factors are efficiently converted without tabulating the levels. This provides more efficiency if a factor is passed to <code>g</code>, but will not drop unused factor levels. The alternative is to use <code>g &lt;- GRP.default(g, return.groups = use.g.names, call = FALSE)</code>, which will get rid of unused factor levels, but using factors for grouping is just as efficient as any other vector.</p>
<pre class="r"><code>head(ganyNA(GGDC10S$SUM, fselect(GGDC10S, Country, Variable)))
## ARG.EMP  ARG.VA BOL.EMP  BOL.VA BRA.EMP  BRA.VA 
##   FALSE   FALSE   FALSE    TRUE   FALSE    TRUE

# 10 million obs and 1 million groups, 1% of data missing 
x &lt;- na_insert(rnorm(1e7), prop = 0.01)
g &lt;- sample.int(1e6, 1e7, TRUE)
system.time(ganyNA(x, g))
##        User      System verstrichen 
##        0.56        0.06        0.66
system.time(ganyNA(x, g, use.g.names = FALSE))
##        User      System verstrichen 
##        0.43        0.04        0.47

# Using a factor grouping variable: More efficient but does not drop any unused levels
f &lt;- qF(g, na.exclude = FALSE) # Efficiently creating a factor (qF is faster as.factor)
system.time(ganyNA(x, f))
##        User      System verstrichen 
##        0.05        0.00        0.05
system.time(ganyNA(x, f, use.g.names = FALSE))
##        User      System verstrichen 
##        0.04        0.00        0.03</code></pre>
<p>We could additionally add a <code>TRA</code> argument and then internally call the <code>TRA()</code> function to allow for replacing and sweeping out statistics, but this does not make much sense here.</p>
</div>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>By default (<code>sort = TRUE</code>) the grouping is ordered, which is equivalent to <em>data.table</em> grouping with <code>keyby</code>.<a href="#fnref1" class="footnote-back">↩︎</a></p></li>
<li id="fn2"><p><code>add_vars</code> is a faster alternative to <code>cbind</code> and <code>get_vars</code> is a faster alternative to <code>[.data.frame</code> for subsetting columns.<a href="#fnref2" class="footnote-back">↩︎</a></p></li>
<li id="fn3"><p>A random effects estimator could easily be added, see the example <a href="https://sebkrantz.github.io/collapse/reference/fbetween_fwithin.html">here</a>.<a href="#fnref3" class="footnote-back">↩︎</a></p></li>
</ol>
</div>

    </div>
  </article>

  


</main>

      <footer class="footer">
        <ul class="footer-links">
          <li>
            <a href="/Rblog/index.xml" type="application/rss+xml" target="_blank">RSS feed</a>
          </li>
          <li>
            <a href="https://gohugo.io/" class="footer-links-kudos">Made with <img src="/Rblog/images/hugo-logo.png" alt="Img link to Hugo website" width="22" height="22"></a>
          </li>
        </ul>
      </footer>

    </div>
    



<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>



<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/r.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/yaml.min.js"></script>
<script>hljs.configure({languages: []}); hljs.initHighlightingOnLoad();</script>



    
<script src="/Rblog/js/math-code.js"></script>
<script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>


    
  </body>
</html>

